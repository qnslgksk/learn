<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>learn repository 정리중</title>
</head>

<body>
    <h2>장애유형</h2>
    <div class="tb_scroll">
        <table class="tb_base">
            <caption><span>장애유형별 장애진단기관 및 전문의 표 - 장애유형[지체장애/뇌병변장애/시각장애/청각장애/언어장애/지적장애/정신장애/자폐성 장애/신장장애/심장장애/호흡기장애/간장애/안면장애/장루 · 요루장애/뇌전증장애], 장애진단기관 및 전문의 등으로 구성</span></caption>
            <colgroup>
                <col style="width:20%;">
                <col style="width:80%;">
            </colgroup>
            <thead>
            <tr>
                <th scope="col" class="bl_none">장애유형</th>
                <th scope="col">장애진단기관 및 전문의 등</th>
            </tr>
            </thead>
            <tbody class="th_center">
            <tr>
                <th scope="row">지체장애</th>
                <td>
                    <ol class="list_mgb10">
                        <li>1. 절단장애 : X-선 촬영시설이 있는 의료기관의 의사</li>
                        <li>2. 기타 지체장애 : X-선 촬영시설 등 검사장비가 있는 의료기관의 재활의학과･정형외과･신경외과･신경과･소아청소년과(신경분과) 또는 내과(류마티스분과) 전문의, 마취통증의학과(CRPS상병인 경우) 전문의</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <th scope="row">뇌병변장애</th>
                <td>의료기관의 재활의학과･신경외과･신경과･소아청소년과(신경분과)전문의 </td>
            </tr>
            <tr>
                <th scope="row">시각장애</th>
                <td>시력 또는 시야결손정도, 겹보임(복시) 정도의 측정이 가능한 의료기관의 안과 전문의</td>
            </tr>
            <tr>
                <th scope="row">청각장애</th>
                <td>방음부스가 있는 청력검사실, 청력검사장비가 있는 의료기관의 이비인후과 전문의</td>
            </tr>
            <tr>
                <th scope="row">언어장애</th>
                <td>
                    <ol class="list_mgb10">
                        <li>1. 의료기관의 재활의학과 전문의 또는 언어재활사가 배치되어 있는 의료기관의 이비인후과･정신건강의학과･신경과･소아청소년과(신경분과) 전문의
                            <p>다만, 음성장애는 언어 재활사가 없는 의료기관의 이비인후과 전문의 포함</p>
                        </li>
                        <li>2. 의료기관의 치과(구강악안면외과) · 치과 전속지도 전문의(구강악안면외과)</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <th scope="row">지적장애</th>
                <td>의료기관의 정신건강의학과･신경과･재활의학과･소아청소년과(신경분과) 전문의</td>
            </tr>
            <tr>
                <th scope="row">정신장애</th>
                <td>
                    <ol class="list_mgb10">
                        <li>1. 장애진단 직전 1년 이상 지속적으로 진료한 정신건강의학과 전문의
                            <p class="txt_emph">지속적으로 진료를 받았다 함은 3개월 이상 약물치료가 중단되지 않았음을 의미</p>
                        </li>
                        <li>2. 1호에 해당하는 전문의가 없는 경우 장애진단 직전 3개월 이상 지속적으로 진료한 의료기관의 정신건강의학과 전문의가 진단할 수 있으나, 장애진단 직전 1년 또는 2년 이상의 지속적인 정신건강의학과 진료기록 등을 확인하여야 한다.</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <th scope="row">자폐성 장애</th>
                <td>의료기관의 정신건강의학과 전문의</td>
            </tr>
            <tr>
                <th scope="row">신장장애</th>
                <td>
                    <ol class="list_mgb10">
                        <li>1. 투석에 대한 장애판정은 장애인 등록 직전 3개월 이상 투석치료를 하고 있는 의료기관의 의사</li>
                        <li>2. 1호에 해당하는 의사가 없을 경우 장애진단 직전 1개월 이상 지속적으로 투석 치료를 하고 있는 의료기관의 의사가 진단할 수 있으나 3개월 이상의 투석 기록을 확인하여야 한다.</li>
                        <li>3. 신장이식의 장애판정은 신장이식을 시술하였거나 이식환자를 진료하는 의료기관의 외과 또는 내과전문의</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <th scope="row">심장장애</th>
                <td>
                    <ol class="list_mgb10">
                        <li>1. 장애진단 직전 1년 이상 진료한 의료기관의 내과(순환기분과 · 소아청소년과 또는 흉부외과 전문의</li>
                        <li>2. 1호에 해당하는 전문의가 없는 경우 의료기관의 내과(순환기분과)･소아청소년과 또는 흉부외과 전문의가 진단할 수 있으나 장애진단 직전 1년 이상 내과(순환기분과)･소아청소년과 또는 흉부외과의 지속적인 진료기록 등을 확인하고 장애진단을 하여야 한다.</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <th scope="row">호흡기장애</th>
                <td>장애진단 직전 2개월 이상 진료한 의료기관의 내과(호흡기분과, 알레르기분과) · 흉부외과 · 소아청소년과 · 결핵과 또는 직업환경의학과 전문의</td>
            </tr>
            <tr>
                <th scope="row">간장애</th>
                <td>장애진단 직전 2개월 이상 진료한 의료기관의 내과(소화기분과) · 외과 또는 소아청소년과 전문의</td>
            </tr>
            <tr>
                <th scope="row">안면장애</th>
                <td>
                    <ul class="cont_list1">
                        <li>의료기관의 성형외과 · 피부과 또는 외과(화상의 경우) 전문의</li>
                        <li>의료기관의 치과(구강악안면외과) · 치과 전속지도 전문의(구강악안면외과)</li>
                    </ul>

                </td>
            </tr>
            <tr>
                <th scope="row">장루 · 요루장애</th>
                <td>의료기관의 외과 · 산부인과  · 비뇨기과 또는 내과 전문의</td>
            </tr>
            <tr>
                <th scope="row">뇌전증장애</th>
                <td>장애진단 직전 6개월 이상 진료한 의료기관의 신경과･신경외과･정신건강의학과･소아청소년과 전문의</td>
            </tr>
            </tbody>
        </table>
    </div>
    <h2>초점접근테스트</h2>
    <p>aria-hidden은 보조기기 접근여부를 컨트롤 하는 속성이고 tabindex는 초점접근 컨트롤 요소이기에 aria-hidden이 있어도 초점 접근이 가능함</p>
    <div id="skipNavi" aria-hidden="true">
        <a href="javascript:;">본문바로가기</a>
    </div>

    <div class="ly_inner">
        <h2>Breadcrumb</h2>
        <div id="ex1">
            <nav aria-label="Breadcrumb" class="breadcrumb">
                <ol>
                    <li>
                        <a href="../../../..">WAI-ARIA Authoring Practices Guide (APG)</a>
                    </li>
                    <li>
                        <a href="../../../">Patterns</a>
                    </li>
                    <li>
                        <a href="../../">Breadcrumb Pattern</a>
                    </li>
                    <li>
                        <a href="" aria-current="page">Breadcrumb Example</a>
                    </li>
                </ol>
            </nav>
        </div>
        <h2></h2>
        <div id="ex1">
            <nav class="stepbar">
                <ol>
                    <li>
                        <span>WAI-ARIA Authoring Practices Guide (APG)</span>
                    </li>
                    <li>
                        <span aria-current="step">Patterns</span>
                    </li>
                    <li>
                        <span>Breadcrumb Pattern</span>
                    </li>
                    <li>
                        <span> Example</span>
                    </li>
                </ol>
            </nav>
        </div>
        <h2>스텝(구)</h2>
        <div class="flow_step" role="text">
            <ul><!--보이스오버: 1스텝,2스텝,3스텝,4스텝 현재1단계진행중 -->
                <li aria-current="step" class="current">1스텝</li> <!--톡백: 현재단계,1스텝, 4개중 1번째 항목4개-->
                <li>2스텝</li><!--톡백: 2스텝, 4개중 2번째 -->
                <li>3스텝</li>
                <li>4스텝</li>
            </ul>
            <span class="ir_txt">현재 1단계 진행중</span><!--톡백: 마지막에 읽어줌 -->
        </div>
        <h2>스텝(뉴)</h2>
        <div class="flow_step bar">
            <ul role="text" aria-label="총 4 단계 중 1단계 진행중"><!--보이스오버: 총 4단계 중 1단계 진행 중-->
                <li aria-current="step" class="current">1단계</li><!--톡백: 총 4단계 중 1단계 진행 중-->
                <li>2단계</li>
                <li>3단계</li>
                <li>4단계</li>
            </ul>
        </div>
    </div>
    <div class="ly_inner">
        <style>
            .listbox-area {
  display: grid;
  grid-gap: 2em;
  grid-template-columns: repeat(2, 1fr);
  padding: 20px;
  border: 1px solid #aaa;
  border-radius: 4px;
  background: #eee;
}

[role="listbox"] {
  margin: 1em 0 0;
  padding: 0;
  min-height: 18em;
  border: 1px solid #aaa;
  background: white;
}

[role="listbox"]#ss_elem_list {
  position: relative;
  max-height: 18em;
  overflow-y: auto;
}

[role="listbox"] + *,
.listbox-label + * {
  margin-top: 1em;
}

[role="group"] {
  margin: 0;
  padding: 0;
}

[role="group"] > [role="presentation"] {
  display: block;
  margin: 0;
  padding: 0 0.5em;
  font-weight: bold;
  line-height: 2;
  background-color: #ccc;
}

[role="option"] {
  position: relative;
  display: block;
  margin: 2px;
  padding: 2px 1em 2px 1.5em;
  line-height: 1.8em;
  cursor: pointer;
}

[role="listbox"]:focus [role="option"].focused {
  background: #bde4ff;
}

[role="listbox"]:focus [role="option"].focused,
[role="option"]:hover {
  outline: 2px solid currentcolor;
}

.move-right-btn span.checkmark::after {
  content: " →";
}

.move-left-btn span.checkmark::before {
  content: "← ";
}

[role="option"][aria-selected="true"] span.checkmark::before {
  position: absolute;
  left: 0.5em;
  content: "✓";
}

button[aria-haspopup="listbox"] {
  position: relative;
  padding: 5px 10px;
  width: 150px;
  border-radius: 0;
  text-align: left;
}

button[aria-haspopup="listbox"]::after {
  position: absolute;
  right: 5px;
  top: 10px;
  width: 0;
  height: 0;
  border: 8px solid transparent;
  border-top-color: currentcolor;
  border-bottom: 0;
  content: "";
}

button[aria-haspopup="listbox"][aria-expanded="true"]::after {
  position: absolute;
  right: 5px;
  top: 10px;
  width: 0;
  height: 0;
  border: 8px solid transparent;
  border-top: 0;
  border-bottom-color: currentcolor;
  content: "";
}

button[aria-haspopup="listbox"] + [role="listbox"] {
  position: absolute;
  margin: 0;
  width: 9.5em;
  max-height: 10em;
  border-top: 0;
  overflow-y: auto;
}

[role="toolbar"] {
  display: flex;
}

[role="toolbar"] > * {
  border: 1px solid #aaa;
  background: #ccc;
}

[role="toolbar"] > [aria-disabled="false"]:focus {
  background-color: #eee;
}

button {
  font-size: inherit;
}

button[aria-disabled="true"] {
  opacity: 0.5;
}

.annotate {
  color: #366ed4;
  font-style: italic;
}

.hidden {
  display: none;
}

.offscreen {
  position: absolute;
  width: 1px;
  height: 1px;
  overflow: hidden;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  font-size: 14px;
  white-space: nowrap;
}

        </style>
        <h2>리스트박스확인중</h2>
        <div class="listbox-area">
            <div>
                <span id="ss_elem" class="listbox-label">Transuranium elements:</span>
                <ul id="ss_elem_list" tabindex="0" role="listbox" aria-labelledby="ss_elem">
        
                    <li id="ss_elem_Cf" role="option" aria-selected="true">
                        <a href="javascript:;" role="button">
                        <span class="checkmark" aria-hidden="true"></span>
                        Californium</a>
                    </li>
                    <li id="ss_elem_Es" role="option" aria-selected="false">
                        <a href="javascript:;" role="button">
                        <span class="checkmark" aria-hidden="true"></span>
                        Einsteinium</a>
                    </li>
        
                    <li id="ss_elem_Hs" role="option" aria-selected="false">
                        <a href="javascript:;" role="button">
                        <span class="checkmark" aria-hidden="true"></span>
                        Hassium</a>
                    </li>
                    <li id="ss_elem_Mt" role="option" aria-selected="false">
                        <a href="javascript:;" role="button">
                        <span class="checkmark" aria-hidden="true"></span>
                        Meitnerium</a>
                    </li>
        
        
        
                </ul>
            </div>
        </div>
        <script>
            /*
     *   This content is licensed according to the W3C Software License at
     *   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     */

                'use strict';

                /**
                 * @namespace aria
                 * @description
                 * The aria namespace is used to support sharing class definitions between example files
                 * without causing eslint errors for undefined classes
                 */
                var aria = aria || {};

                /**
                 * @class
                 * @description
                 *  Listbox object representing the state and interactions for a listbox widget
                 * @param listboxNode
                 *  The DOM node pointing to the listbox
                 */

                aria.Listbox = class Listbox {
                    constructor(listboxNode) {
                        this.listboxNode = listboxNode;
                        this.activeDescendant = this.listboxNode.getAttribute(
                            'aria-activedescendant'
                        );
                        this.multiselectable = this.listboxNode.hasAttribute(
                            'aria-multiselectable'
                        );
                        this.moveUpDownEnabled = false;
                        this.siblingList = null;
                        this.startRangeIndex = 0;
                        this.upButton = null;
                        this.downButton = null;
                        this.moveButton = null;
                        this.keysSoFar = '';
                        this.handleFocusChange = function () { };
                        this.handleItemChange = function () { };
                        this.registerEvents();
                    }

                    registerEvents() {
                        this.listboxNode.addEventListener('focus', this.setupFocus.bind(this));
                        this.listboxNode.addEventListener('keydown', this.checkKeyPress.bind(this));
                        this.listboxNode.addEventListener('click', this.checkClickItem.bind(this));

                        if (this.multiselectable) {
                            this.listboxNode.addEventListener(
                                'mousedown',
                                this.checkMouseDown.bind(this)
                            );
                        }
                    }

                    setupFocus() {
                        if (this.activeDescendant) {
                            const listitem = document.getElementById(this.activeDescendant);
                            listitem.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                        }
                    }

                    focusFirstItem() {
                        var firstItem = this.listboxNode.querySelector('[role="option"]');

                        if (firstItem) {
                            this.focusItem(firstItem);
                        }
                    }

                    focusLastItem() {
                        const itemList = this.listboxNode.querySelectorAll('[role="option"]');

                        if (itemList.length) {
                            this.focusItem(itemList[itemList.length - 1]);
                        }
                    }

                    checkKeyPress(evt) {
                        const lastActiveId = this.activeDescendant;
                        const allOptions = this.listboxNode.querySelectorAll('[role="option"]');
                        const currentItem =
                            document.getElementById(this.activeDescendant) || allOptions[0];
                        let nextItem = currentItem;

                        if (!currentItem) {
                            return;
                        }

                        switch (evt.key) {
                            case 'PageUp':
                            case 'PageDown':
                                evt.preventDefault();
                                if (this.moveUpDownEnabled) {
                                    if (evt.key === 'PageUp') {
                                        this.moveUpItems();
                                    } else {
                                        this.moveDownItems();
                                    }
                                }

                                break;
                            case 'ArrowUp':
                            case 'ArrowDown':
                                evt.preventDefault();
                                if (!this.activeDescendant) {
                                    // focus first option if no option was previously focused, and perform no other actions
                                    this.focusItem(currentItem);
                                    break;
                                }

                                if (this.moveUpDownEnabled && evt.altKey) {
                                    evt.preventDefault();
                                    if (evt.key === 'ArrowUp') {
                                        this.moveUpItems();
                                    } else {
                                        this.moveDownItems();
                                    }
                                    this.updateScroll();
                                    return;
                                }

                                if (evt.key === 'ArrowUp') {
                                    nextItem = this.findPreviousOption(currentItem);
                                } else {
                                    nextItem = this.findNextOption(currentItem);
                                }

                                if (nextItem && this.multiselectable && event.shiftKey) {
                                    this.selectRange(this.startRangeIndex, nextItem);
                                }

                                if (nextItem) {
                                    this.focusItem(nextItem);
                                }

                                break;

                            case 'Home':
                                evt.preventDefault();
                                this.focusFirstItem();

                                if (this.multiselectable && evt.shiftKey && evt.ctrlKey) {
                                    this.selectRange(this.startRangeIndex, 0);
                                }
                                break;

                            case 'End':
                                evt.preventDefault();
                                this.focusLastItem();

                                if (this.multiselectable && evt.shiftKey && evt.ctrlKey) {
                                    this.selectRange(this.startRangeIndex, allOptions.length - 1);
                                }
                                break;

                            case 'Shift':
                                this.startRangeIndex = this.getElementIndex(currentItem, allOptions);
                                break;

                            case ' ':
                                evt.preventDefault();
                                this.toggleSelectItem(nextItem);
                                break;

                            case 'Backspace':
                            case 'Delete':
                            case 'Enter':
                                if (!this.moveButton) {
                                    return;
                                }

                                var keyshortcuts = this.moveButton.getAttribute('aria-keyshortcuts');
                                if (evt.key === 'Enter' && keyshortcuts.indexOf('Enter') === -1) {
                                    return;
                                }
                                if (
                                    (evt.key === 'Backspace' || evt.key === 'Delete') &&
                                    keyshortcuts.indexOf('Delete') === -1
                                ) {
                                    return;
                                }

                                evt.preventDefault();

                                var nextUnselected = nextItem.nextElementSibling;
                                while (nextUnselected) {
                                    if (nextUnselected.getAttribute('aria-selected') != 'true') {
                                        break;
                                    }
                                    nextUnselected = nextUnselected.nextElementSibling;
                                }
                                if (!nextUnselected) {
                                    nextUnselected = nextItem.previousElementSibling;
                                    while (nextUnselected) {
                                        if (nextUnselected.getAttribute('aria-selected') != 'true') {
                                            break;
                                        }
                                        nextUnselected = nextUnselected.previousElementSibling;
                                    }
                                }

                                this.moveItems();

                                if (!this.activeDescendant && nextUnselected) {
                                    this.focusItem(nextUnselected);
                                }
                                break;

                            case 'A':
                            case 'a':
                                // handle control + A
                                if (evt.ctrlKey || evt.metaKey) {
                                    if (this.multiselectable) {
                                        this.selectRange(0, allOptions.length - 1);
                                    }
                                    evt.preventDefault();
                                    break;
                                }
                            // fall through
                            default:
                                if (evt.key.length === 1) {
                                    const itemToFocus = this.findItemToFocus(evt.key.toLowerCase());
                                    if (itemToFocus) {
                                        this.focusItem(itemToFocus);
                                    }
                                }
                                break;
                        }

                        if (this.activeDescendant !== lastActiveId) {
                            this.updateScroll();
                        }
                    }

                    findItemToFocus(character) {
                        const itemList = this.listboxNode.querySelectorAll('[role="option"]');
                        let searchIndex = 0;

                        if (!this.keysSoFar) {
                            for (let i = 0; i < itemList.length; i++) {
                                if (itemList[i].getAttribute('id') == this.activeDescendant) {
                                    searchIndex = i;
                                }
                            }
                        }

                        this.keysSoFar += character;
                        this.clearKeysSoFarAfterDelay();

                        let nextMatch = this.findMatchInRange(
                            itemList,
                            searchIndex + 1,
                            itemList.length
                        );

                        if (!nextMatch) {
                            nextMatch = this.findMatchInRange(itemList, 0, searchIndex);
                        }
                        return nextMatch;
                    }

                    /* Return the index of the passed element within the passed array, or null if not found */
                    getElementIndex(option, options) {
                        const allOptions = Array.prototype.slice.call(options); // convert to array
                        const optionIndex = allOptions.indexOf(option);

                        return typeof optionIndex === 'number' ? optionIndex : null;
                    }

                    /* Return the next listbox option, if it exists; otherwise, returns null */
                    findNextOption(currentOption) {
                        const allOptions = Array.prototype.slice.call(
                            this.listboxNode.querySelectorAll('[role="option"]')
                        ); // get options array
                        const currentOptionIndex = allOptions.indexOf(currentOption);
                        let nextOption = null;

                        if (currentOptionIndex > -1 && currentOptionIndex < allOptions.length - 1) {
                            nextOption = allOptions[currentOptionIndex + 1];
                        }

                        return nextOption;
                    }

                    /* Return the previous listbox option, if it exists; otherwise, returns null */
                    findPreviousOption(currentOption) {
                        const allOptions = Array.prototype.slice.call(
                            this.listboxNode.querySelectorAll('[role="option"]')
                        ); // get options array
                        const currentOptionIndex = allOptions.indexOf(currentOption);
                        let previousOption = null;

                        if (currentOptionIndex > -1 && currentOptionIndex > 0) {
                            previousOption = allOptions[currentOptionIndex - 1];
                        }

                        return previousOption;
                    }

                    clearKeysSoFarAfterDelay() {
                        if (this.keyClear) {
                            clearTimeout(this.keyClear);
                            this.keyClear = null;
                        }
                        this.keyClear = setTimeout(
                            function () {
                                this.keysSoFar = '';
                                this.keyClear = null;
                            }.bind(this),
                            500
                        );
                    }

                    findMatchInRange(list, startIndex, endIndex) {
                        // Find the first item starting with the keysSoFar substring, searching in
                        // the specified range of items
                        for (let n = startIndex; n < endIndex; n++) {
                            const label = list[n].innerText;
                            if (label && label.toLowerCase().indexOf(this.keysSoFar) === 0) {
                                return list[n];
                            }
                        }
                        return null;
                    }

                    checkClickItem(evt) {
                        if (evt.target.getAttribute('role') !== 'option') {
                            return;
                        }

                        this.focusItem(evt.target);
                        this.toggleSelectItem(evt.target);
                        this.updateScroll();

                        if (this.multiselectable && evt.shiftKey) {
                            this.selectRange(this.startRangeIndex, evt.target);
                        }
                    }

                    /**
                     * Prevent text selection on shift + click for multi-select listboxes
                     *
                     * @param evt
                     */
                    checkMouseDown(evt) {
                        if (
                            this.multiselectable &&
                            evt.shiftKey &&
                            evt.target.getAttribute('role') === 'option'
                        ) {
                            evt.preventDefault();
                        }
                    }

                    /**
                     * @description
                     *  Toggle the aria-selected value
                     * @param element
                     *  The element to select
                     */
                    toggleSelectItem(element) {
                        if (this.multiselectable) {
                            element.setAttribute(
                                'aria-selected',
                                element.getAttribute('aria-selected') === 'true' ? 'false' : 'true'
                            );

                            this.updateMoveButton();
                        }
                    }

                    /**
                     * @description
                     *  Defocus the specified item
                     * @param element
                     *  The element to defocus
                     */
                    defocusItem(element) {
                        if (!element) {
                            return;
                        }
                        if (!this.multiselectable) {
                            element.removeAttribute('aria-selected');
                        }
                        element.classList.remove('focused');
                    }

                    /**
                     * @description
                     *  Focus on the specified item
                     * @param element
                     *  The element to focus
                     */
                    focusItem(element) {
                        this.defocusItem(document.getElementById(this.activeDescendant));
                        if (!this.multiselectable) {
                            element.setAttribute('aria-selected', 'true');
                        }
                        element.classList.add('focused');
                        this.listboxNode.setAttribute('aria-activedescendant', element.id);
                        this.activeDescendant = element.id;

                        if (!this.multiselectable) {
                            this.updateMoveButton();
                        }

                        this.checkUpDownButtons();
                        this.handleFocusChange(element);
                    }

                    /**
                     * Helper function to check if a number is within a range; no side effects.
                     *
                     * @param index
                     * @param start
                     * @param end
                     * @returns {boolean}
                     */
                    checkInRange(index, start, end) {
                        const rangeStart = start < end ? start : end;
                        const rangeEnd = start < end ? end : start;

                        return index >= rangeStart && index <= rangeEnd;
                    }

                    /**
                     * Select a range of options
                     *
                     * @param start
                     * @param end
                     */
                    selectRange(start, end) {
                        // get start/end indices
                        const allOptions = this.listboxNode.querySelectorAll('[role="option"]');
                        const startIndex =
                            typeof start === 'number'
                                ? start
                                : this.getElementIndex(start, allOptions);
                        const endIndex =
                            typeof end === 'number' ? end : this.getElementIndex(end, allOptions);

                        for (let index = 0; index < allOptions.length; index++) {
                            const selected = this.checkInRange(index, startIndex, endIndex);
                            allOptions[index].setAttribute('aria-selected', selected + '');
                        }

                        this.updateMoveButton();
                    }

                    /**
                     * Check for selected options and update moveButton, if applicable
                     */
                    updateMoveButton() {
                        if (!this.moveButton) {
                            return;
                        }

                        if (this.listboxNode.querySelector('[aria-selected="true"]')) {
                            this.moveButton.setAttribute('aria-disabled', 'false');
                        } else {
                            this.moveButton.setAttribute('aria-disabled', 'true');
                        }
                    }

                    /**
                     * Check if the selected option is in view, and scroll if not
                     */
                    updateScroll() {
                        const selectedOption = document.getElementById(this.activeDescendant);
                        if (selectedOption) {
                            const scrollBottom =
                                this.listboxNode.clientHeight + this.listboxNode.scrollTop;
                            const elementBottom =
                                selectedOption.offsetTop + selectedOption.offsetHeight;
                            if (elementBottom > scrollBottom) {
                                this.listboxNode.scrollTop =
                                    elementBottom - this.listboxNode.clientHeight;
                            } else if (selectedOption.offsetTop < this.listboxNode.scrollTop) {
                                this.listboxNode.scrollTop = selectedOption.offsetTop;
                            }
                            selectedOption.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                        }
                    }

                    /**
                     * @description
                     *  Enable/disable the up/down arrows based on the activeDescendant.
                     */
                    checkUpDownButtons() {
                        const activeElement = document.getElementById(this.activeDescendant);

                        if (!this.moveUpDownEnabled) {
                            return;
                        }

                        if (!activeElement) {
                            this.upButton.setAttribute('aria-disabled', 'true');
                            this.downButton.setAttribute('aria-disabled', 'true');
                            return;
                        }

                        if (this.upButton) {
                            if (activeElement.previousElementSibling) {
                                this.upButton.setAttribute('aria-disabled', false);
                            } else {
                                this.upButton.setAttribute('aria-disabled', 'true');
                            }
                        }

                        if (this.downButton) {
                            if (activeElement.nextElementSibling) {
                                this.downButton.setAttribute('aria-disabled', false);
                            } else {
                                this.downButton.setAttribute('aria-disabled', 'true');
                            }
                        }
                    }

                    /**
                     * @description
                     *  Add the specified items to the listbox. Assumes items are valid options.
                     * @param items
                     *  An array of items to add to the listbox
                     */
                    addItems(items) {
                        if (!items || !items.length) {
                            return;
                        }

                        items.forEach(
                            function (item) {
                                this.defocusItem(item);
                                this.toggleSelectItem(item);
                                this.listboxNode.append(item);
                            }.bind(this)
                        );

                        if (!this.activeDescendant) {
                            this.focusItem(items[0]);
                        }

                        this.handleItemChange('added', items);
                    }

                    /**
                     * @description
                     *  Remove all of the selected items from the listbox; Removes the focused items
                     *  in a single select listbox and the items with aria-selected in a multi
                     *  select listbox.
                     * @returns {Array}
                     *  An array of items that were removed from the listbox
                     */
                    deleteItems() {
                        let itemsToDelete;

                        if (this.multiselectable) {
                            itemsToDelete = this.listboxNode.querySelectorAll(
                                '[aria-selected="true"]'
                            );
                        } else if (this.activeDescendant) {
                            itemsToDelete = [document.getElementById(this.activeDescendant)];
                        }

                        if (!itemsToDelete || !itemsToDelete.length) {
                            return [];
                        }

                        itemsToDelete.forEach(
                            function (item) {
                                item.remove();

                                if (item.id === this.activeDescendant) {
                                    this.clearActiveDescendant();
                                }
                            }.bind(this)
                        );

                        this.handleItemChange('removed', itemsToDelete);

                        return itemsToDelete;
                    }

                    clearActiveDescendant() {
                        this.activeDescendant = null;
                        this.listboxNode.setAttribute('aria-activedescendant', null);

                        this.updateMoveButton();
                        this.checkUpDownButtons();
                    }

                    /**
                     * @description
                     *  Shifts the currently focused item up on the list. No shifting occurs if the
                     *  item is already at the top of the list.
                     */
                    moveUpItems() {
                        if (!this.activeDescendant) {
                            return;
                        }

                        const currentItem = document.getElementById(this.activeDescendant);
                        const previousItem = currentItem.previousElementSibling;

                        if (previousItem) {
                            this.listboxNode.insertBefore(currentItem, previousItem);
                            this.handleItemChange('moved_up', [currentItem]);
                        }

                        this.checkUpDownButtons();
                    }

                    /**
                     * @description
                     *  Shifts the currently focused item down on the list. No shifting occurs if
                     *  the item is already at the end of the list.
                     */
                    moveDownItems() {
                        if (!this.activeDescendant) {
                            return;
                        }

                        var currentItem = document.getElementById(this.activeDescendant);
                        var nextItem = currentItem.nextElementSibling;

                        if (nextItem) {
                            this.listboxNode.insertBefore(nextItem, currentItem);
                            this.handleItemChange('moved_down', [currentItem]);
                        }

                        this.checkUpDownButtons();
                    }

                    /**
                     * @description
                     *  Delete the currently selected items and add them to the sibling list.
                     */
                    moveItems() {
                        if (!this.siblingList) {
                            return;
                        }

                        var itemsToMove = this.deleteItems();
                        this.siblingList.addItems(itemsToMove);
                    }

                    /**
                     * @description
                     *  Enable Up/Down controls to shift items up and down.
                     * @param upButton
                     *   Up button to trigger up shift
                     * @param downButton
                     *   Down button to trigger down shift
                     */
                    enableMoveUpDown(upButton, downButton) {
                        this.moveUpDownEnabled = true;
                        this.upButton = upButton;
                        this.downButton = downButton;
                        upButton.addEventListener('click', this.moveUpItems.bind(this));
                        downButton.addEventListener('click', this.moveDownItems.bind(this));
                    }

                    /**
                     * @description
                     *  Enable Move controls. Moving removes selected items from the current
                     *  list and adds them to the sibling list.
                     * @param button
                     *   Move button to trigger delete
                     * @param siblingList
                     *   Listbox to move items to
                     */
                    setupMove(button, siblingList) {
                        this.siblingList = siblingList;
                        this.moveButton = button;
                        button.addEventListener('click', this.moveItems.bind(this));
                    }

                    setHandleItemChange(handlerFn) {
                        this.handleItemChange = handlerFn;
                    }

                    setHandleFocusChange(focusChangeHandler) {
                        this.handleFocusChange = focusChangeHandler;
                    }
                };
                /*
                 *   This content is licensed according to the W3C Software License at
                 *   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
                 */

                'use strict';

                /**
                 * @namespace aria
                 * @description
                 * The aria namespace is used to support sharing class definitions between example files
                 * without causing eslint errors for undefined classes
                 */
                var aria = aria || {};

                /**
                 * ARIA Scrollable Listbox Example
                 *
                 * @function onload
                 * @description Initialize the listbox example once the page has loaded
                 */

                window.addEventListener('load', function () {
                    new aria.Listbox(document.getElementById('ss_elem_list'));
                });

        </script>
    </div>
    <div class="ly_inner">
        <h2>초점분리 현상0 role button</h2>
        <div>
            <a href="javascript:; " class="item" role="button">
                <div>
                    <dl>
                        <!-- 
                            iOS: 내부 텍스트를 한 번에 읽어주고 버튼이라 함
                            Android: 
                        -->
                        <dt>제품명</dt>
                        <dd>달콤한딸기 500g</dd>
                        <dt>가격</dt>
                        <dd>10000<span style="font-weight:bold">원</span></dd>
                    </dl>
                </div>
            </a>
        </div>

        <h2>초점분리 현상1 aria-label aria-hidden</h2>
        <div>
            <a href="javascript:;" class="item" aria-label="제품명 달콤한딸기 500g 가격 10000원">
                <div aria-hidden="true">
                    <dl>
                        <!-- 
                            iOS: aria-label값을 읽고 aria-hidden="true"로 인해 내부태그는 읽지 않음
                            Android: 
                        -->
                        <dt>제품명</dt>
                        <dd>달콤한딸기 500g</dd>
                        <dt>가격</dt>
                        <dd>10000<span style="font-weight:bold">원</span></dd>
                    </dl>
                </div>
            </a>
        </div>

        <h2>초점분리 현상2 role="text"</h2>
        <div>
            <a href="javascript:;" class="item">
                <div role="text"><!-- role="text" ios에서만 사용 가능한 비공식 속성 -->
                    <dl>
                        <!-- 
                            iOS: 내부텍스트는 동일하게 읽어주고 용어,정의 명시는 하지 않음
                            Android: 
                        -->
                        <dt>제품명</dt>
                        <dd>달콤한포도 500g</dd>
                        <dt>가격</dt>
                        <dd>10000<span style="font-weight:bold">원</span></dd>
                    </dl>
                </div>
            </a>
        </div>

        <h2>초점분리 현상3 링크아닌요소 aria-label</h2>
        <div>
            <div class="item">
                <div>
                    <dl role="text">
                        <!-- 
                            iOS: aria-label 안읽음 /
                            제품명, 설명 목록 시작,용어
                            달콤한포도 500g, 설명
                            가격, 용어
                            10000 ,설명
                            설명 목록 끝, 설명
                            /
                            Android: 
                        -->
                        <dt>제품명</dt>
                        <dd>달콤한포도 500g</dd>
                        <dt>가격</dt>
                        <dd>10000<span>원</span></dd>
                    </dl>
                </div>
            </div>
        </div>
    </div>

    <div class="ly_inner">
        <style>
            *{margin:0; padding:0;}
            body{padding:16px;}
            .ir_txt{overflow:hidden; display:block; position:absolute; border:0; width:1px; height:1px; clip:rect(1px,1px,1px,1px)}
            .list4 {border-top: 1px solid #888; border-bottom: 1px solid #ddd;}
            ul{margin:0; padding:0;}
            li{list-style:none;}
            .list4-item {position:relative; display: flex; align-items: center; padding: 30px 0;}
            .list4-item + .list4-item {border-top: 1px solid #ddd;}        
    input{appearance:none; -webkit-appearance: none; -moz-appearance: none;}
    /* input[type="checkbox"] */
    .list4-check.custom .check_wrap{margin-right: 16px;}
    .list4-check.custom input[type="checkbox"]{overflow:hidden; position:relative; width:24px; height:24px; border:1px solid #ddd;border-radius:50%;}
    .list4-check.custom input[type="checkbox"]::before{content:''; position:absolute; width:100%; height:100%; background:url('https://www.shinhancard.com/pconts/images/dx/com/icon_check_ccc.svg')}
    .list4-check.custom input[type="checkbox"]:checked::before{content:''; position:absolute; width:100%; height:100%; background:#476eff url('https://www.shinhancard.com/pconts/images/dx/com/icon_check_white.svg') no-repeat;}
    /* label */
    .list4-check.custom .check_wrap label{position:absolute; top:0; left:0; width:100%; height:100%;}
    /** 커스텀 끝*/
            .check-dx{position:relative; width: 24px; height: 24px; margin-right:16px;}
            .check-dx.check-only .check_default {display: block; width: 100%; height: 100%; cursor: pointer;}
            .check_default input[type="checkbox"] {width: 24px; height: 24px; position: absolute; left: 0; top: 0; z-index: 1; opacity: 0; border-radius: 50%; margin: 0; padding: 0; cursor: pointer;}
            .check_default input[type="checkbox"] + span {overflow: hidden;z-index: 0; display: block; width: 100%; height: 100%; padding-left: 0;}
            .check_default input[type="checkbox"]:checked + span::before {background: #476eff url('https://www.shinhancard.com/pconts/images/dx/com/icon_check_white.svg') no-repeat center;}
            
            .check_default input[type="checkbox"] + span::before {content:''; position: absolute; left: 0; top: 0px; width: 24px; height: 24px; border: 1px solid #ccc; border-radius: 50%;}
            .check_default input[type="checkbox"]:focus + span {
        box-shadow: 0 0 0 2px rgba(72, 104, 225, 0.5);
    }
        </style>
        <h2>label test ing</h2>
        <div class="list4">
            <ul class="list4-group">
                <li class="list4-item">
                    <div class="list4-check custom">
                        <div class="check_wrap">
                            <label class="check_default" for="check1"><span class="ir_txt">1번 커스텀레이블</span></label>
                            <input type="checkbox" id="check1" name="checkN1" checked>
                        </div>
                    </div>
                    <div class="list4-info">
                        <div class="list4-tit" aria-hidden="true">1.암묵적레이블</div>
                        <div class="list4-cardnum">4518-12**-****-4701</div>
                        <div class="default-txt md-txt">
                            <span>본인</span>
                            <span>1227</span>
                            <span class="ico_card_logo ct02" role="text">마스터 카드</span>
                        </div>
                        <div class="default-txt md-txt">발급월 2018-08</div>
                    </div>
                </li>            
                <li class="list4-item">
                    <div class="list4-check">
                        <div class="check_wrap check-dx check-only">
                            <label for="check1" class="check_default">
                                <input type="checkbox" id="check1" name="checkN1" checked="" class="set_AutoComplete" autocomplete="off">
                                <span role="text">1번 - 타이틀</span>
                            </label>
                        </div>
                    </div>

                    <div class="list4-info">
                        <div class="list4-tit">1번 - 타이틀</div>
                        <div class="list4-cardnum">4518-12**-****-4701</div>
                        <div class="default-txt md-txt">
                            <span>본인</span>
                            <span>1227</span>
                            <span class="ico_card_logo ct02" role="text">마스터 카드</span>
                        </div>
                        <div class="default-txt md-txt">발급월 2018-08</div>
                    </div>
                </li>
                <li class="list4-item">
                    <div class="list4-check">
                        <div class="check_wrap check-dx check-only">
                            <div class="check_default">
                                <input type="checkbox" id="check2" name="checkN2" class="set_AutoComplete" autocomplete="off">
                                <span role="text"></span>
                            </div>
                        </div>
                    </div>

                    <div class="list4-info">
                        <label for="check2" class="list4-tit">2번 - 타이틀</label>
                        <div class="list4-cardnum">4518-12**-****-4701</div>
                        <div class="default-txt md-txt">
                            <span>본인</span>
                            <span>1227</span>
                            <span class="ico_card_logo ct02" role="text">마스터 카드</span>
                        </div>
                        <div class="default-txt md-txt">발급월 2018-08</div>
                    </div>
                </li>
                <li class="list4-item">
                    <div class="list4-check">
                        <div class="check_wrap check-dx check-only">
                            <div class="check_default">
                                <input type="checkbox" id="check3" name="checkN3" class="set_AutoComplete" autocomplete="off">
                                <span role="text"></span>
                            </div>
                        </div>
                    </div>

                    <label class="list4-info" for="check3">
                        <div class="list4-tit">3번 - 타이틀</div>
                        <div class="list4-cardnum">4518-12**-****-4701</div>
                        <div class="default-txt md-txt">
                            <span>본인</span>
                            <span>1227</span>
                            <span class="ico_card_logo ct02" role="text">마스터 카드</span>
                        </div>
                        <div class="default-txt md-txt">발급월 2018-08</div>
                    </label>
                </li>
            </ul>
        </div>
    </div>
    <div class="ly_inner">
        <style>
            #box {
                width: 300px;
                height: 30px;
                background-color: darkblue;
            }
            
        </style>
        
        <div id="box" tabindex="0"></div>
        <script>
            const element = document.getElementById("box");
    
            element.scrollIntoView();
            element.scrollIntoView(false);
            element.scrollIntoView({ block: "end" });
            element.scrollIntoView({ behavior: "smooth", block: "end", inline: "nearest" });
        </script>
    
    </div>
    <div class="ly_inner" style="margin-bottom:1000px;">
        <ul>
            <li class="item"><a href="javascript:;">1</a></li>
            <li class="item"><a href="javascript:;">2</a></li>
            <li class="item"><a href="javascript:;">3</a></li>
            <li class="item"><a href="javascript:;">4</a></li>
            <li class="item"><a href="javascript:;">5</a></li>
            <li class="item"><a href="javascript:;">6</a></li>
            <li class="item"><a href="javascript:;">7</a></li>
            <li class="item"><a href="javascript:;">8</a></li>
            <li class="item"><a href="javascript:;">9</a></li>
            <li class="item"><a href="javascript:;">10</a></li>
        </ul>
    </div>
    <div class="ly_inner">
        <style>
            .floating_wrap{position:fixed; top:auto; right:0; bottom:0; left:0; padding:16px; background-color:#888}
            .floating_wrap .float_btn{all:unset; display:inline-block; width:100%; padding-top:8px; padding-bottom:8px;background-color:#476eff; color:#fff; text-align:center;}
            /*appearance: none;*/
        </style>
        <div class="floating_wrap">
            <button type="button" class="float_btn">나는 플로팅버튼</button>
        </div>
        <script>
            document.addEventListener('DOMContentLoaded', function(){ //ready
                addEventListener("scroll", () => {
                    var y = window.pageYOffset
                    console.log(y);
                }, false);// 스크롤이벤트
                // window.scrollY  IE미지원 읽기전용
                // window.pageYOffset; IE지원 읽기전용
                console.dir(document.compatMode)
                var el = document.querySelector("#box");
                var elY = el.offsetTop;
                console.log(elY)
                // window.scroll 스크롤이동 scrollTo와 같음
                // window.scrollBy 현재스크롤기준 스크롤이동
                // window.scrollTo  문서왼쪽위모서리 기준 스크롤이동
                
                var box = document.querySelector("#box")
                box.addEventListener("focus", function(){
                    box.scrollIntoView({
                        behavior:"smooth",
                        block:"center",
                    }) // 초점이 오면 ele가 보이는 상태로 문서왼쪽위모서리로 스크롤이동
                }, false);
                /* 포커스 들어오는 엘리먼트의 좌표를 offsetTop으로 알아오고
                문서의 중앙정렬을 위해 scroll위치값을 window.innerHeight/2
                요소의 절반값을 빼고 ㅎㄷㄷ;;*/

                // IE9미만지원;;
                var supportPageOffsetX = window.pageXOffset !== undefined;
                var supportPageOffsetY = window.pageYOffset !== undefined;
                // document.compatMode 문서렌더링모드체크 BackCompat || CSS1Compat
                var isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");
                var x = supportPageOffsetX ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
                var y = supportPageOffsetY ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

                
            }, false);
            
        </script>
    </div>


  

    
</body>

</html>